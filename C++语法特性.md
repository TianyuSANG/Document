#### 1）引用

格式：类型名 & 引用名 = 某变量

```
int n = 4;
int & r = n; // r引用了变量n
```

约束：引用等价于变量的别名

1、引用声明时就要引用一个变量，并从一而终

2、引用只能引用变量，不能引用常量和表达式

引用的应用：

1、引用可以作为函数参数

2、引用可以作为函数的返回值

3、常引用

```
int n;
const int & r = n;
r = 200; // 编译报错
n = 300; // 编译正确
```

非常引用类型的变量可以用于初始化常引用

常引用类型的变量不可以用于初始化非常引用，除非强制类型转换



#### 2）const关键字

1、定义常量

2、定义常量指针 

1）不可以修改指向的内容，可以修改指向

2）不能把常量指针赋值给非常量指针，除非强制类型转换，可以把非常量指针赋值给常量指针

3）函数参数为常量指针，可以避免通过指针修改内容

3、定义常引用



#### 3）动态内容分配



1、用new运算符实现动态内存分配

```
p = new T;
p = new T[n];
```

2、用delete运算符去删除动态分配的内存

```
delete p;
delete []p;
```



#### 4）内联函数和重载函数和函数缺省参数

1、内联函数，减少函数调用开销，将整个函数的代码插入到调用代码处

2、函数重载，一个或多个函数，名字相同，参数个数或参数类型不相同

3、函数的缺省参数

函数定义处函数的参数，右边连续若干个允许有默认值

允许函数调用时，不指定右边若干个参数



#### 5）类和对象

1、class

2、对象的内存分配和结构体变量一样，占用空间等于所有成员变量大小之和

3、每个丢向都有自己的存储空间

4、对象间的运算 通过运算符的重载运算

5、使用类的成员变量和成员函数

6、类成员的访问范围

private：私有成员，只能在成员函数内访问

public：共有成员，可以在任何地方范文

protected：保护成员，以后再说

如果没有关键字修饰，缺省认为是私有成员

7、类的成员函数内部，可以访问

--当前对象的全部属性、函数；

--同类其他对象的全部属性、函数

8、类的成员函数外部，只能访问类的共有成员

9、成员函数的重载及参数缺省

--成员函数可以重载

--成员函数可以带缺省参数



#### 6) 构造函数

1、成员函数的一种，名字与类名相同，可以有参数，不能有返回值（void也不行）用于对对象进行初始化，没写构造函数 编译器生成一个默认的没有参数的构造函数

2、如果定义了构造函数，就不会生成默认的无参数的构造函数

3、一个类可以有多个构造函数，参数个数或类型不同



#### 7) 复制构造函数

1、只有一个参数，即对同类对象的引用

X::X(X &) 或者 X::X(const X &)，二者选一

2、如果没有定义复制构造函数，编译器生成默认的

3、不允许有形如 X::X(X)的构造函数

4、复制构造函数起作用的三种情况：

--1）当一个对象去初始化同类的另一个对象

Complex c2(c1) 等价于 Complex c2 = c1；

--2）如果某函数有一个参数是类A的对象，该函数被调用时，类A的复制构造函数将被调用

--3）如果函数的返回值是类A的对象，函数返回时，类A的复制构造函数将被调用。

5、对象间赋值，不会导致复制构造函数被调用。



#### 8）类型转换构造函数

1、定义类型转换构造函数目的实现类型的自动转换

2、只有一个参数，而且不是复制构造函数的构造函数，一般可以看作时转换构造函数

3、当需要的时候，编译系统会自动调用转换构造函数，建立一个无名的临时对象（或临时变量）



#### 9）析构函数

1、名字与类名相同，在前面加~，没有参数和返回值。一个类最多只能有一个析构函数。

2、析构函数对象消亡时自动被调用。

3、如果没写析构函数，编译器自动生成缺省析构函数，缺省析构函数什么也不做。

4、如果定义了析构函数，编译器不会生成缺省析构函数

5、析构函数和运算符delete

--delete运算导致析构函数调用

--如果new一个对象数组，delete释放时应该写[]



#### 10)构造函数和析构函数调用时机

1、构造函数 生成对象时调用

2、析构函数 销毁对象时调用